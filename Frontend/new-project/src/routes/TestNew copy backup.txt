import React, { useState, useEffect, cloneElement } from 'react';
import { FilterMatchMode, FilterOperator } from 'primereact/api';
import { DataTable } from 'primereact/datatable';
import { Column } from 'primereact/column';
import { InputText } from 'primereact/inputtext';
import { MultiSelect } from 'primereact/multiselect';
import { Button } from 'primereact/button';
import { Calendar } from 'primereact/calendar';
import { Panel } from 'primereact/panel';
import { SelectButton } from 'primereact/selectbutton';
import { Text } from "@chakra-ui/react";
import { Dropdown } from 'primereact/dropdown';
import { AutoComplete } from "primereact/autocomplete";
import { Tag } from 'primereact/tag';

export default function BasicFilterDemo() {
    const [data, setData] = useState(null);
    const [field, setField] = useState(null);
    const [columnMinWidths, setColumnMinWidths] = useState({}); // State untuk menyimpan lebar minimum kolom
    const [headerMinWidths, setHeaderMinWidths] = useState({}); // State untuk menyimpan lebar minimum kolom
    const [loading, setLoading] = useState(true);
    const [globalFilterValue, setGlobalFilterValue] = useState('');
    const statusesName = [...new Set(data?.map((item) => item.statusProjek))];

    const [sizeOptions] = useState([
        { label: 'Small', value: 'small' },
        { label: 'Normal', value: 'normal' },
        { label: 'Large', value: 'large' }
    ]);
    const [size, setSize] = useState(sizeOptions[0].value);
    // const field = data?.slice(0, 1).map(obj => Object.keys(obj))[0];
    // Membuat Set untuk menyimpan nilai unik
    // const uniqueValuesNamaProjek = new Set(data?.map(item => item.namaProjek));
    // console.log(uniqueValuesNamaProjek);
    // // Menggunakan Set ke dalam array hasilTransformasi
    // const namaProjekMap = Array.from(uniqueValuesNamaProjek).map(namaProjek => ({ namaProjek }));
    // console.log(namaProjekMap);
    // console.log(field);
    const [filters, setFilters] = useState({
        global: { value: null, matchMode: FilterMatchMode.CONTAINS },
        kodeProjek: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        namaProjek: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        namaDivisi: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        namaDepartemen: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        namaMaterialGrup: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        kodeMaterial: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        namaMaterial: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        // namaMaterial: { operator: FilterOperator.OR, constraints: [{ value: 'bantu', matchMode: FilterMatchMode.CONTAINS }, { value: 'net', matchMode: FilterMatchMode.CONTAINS }] },
        uom: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        nomorPo: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        tanggalPo: { operator: FilterOperator.AND, constraints: [{ value: null, matchMode: FilterMatchMode.DATE_IS }] },
        poQuantity: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        poPrice: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        poTotalValue: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        kodeVendor: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        namaVendor: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        kodeGr: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        tanggalGr: { operator: FilterOperator.AND, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        grQuantity: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        grValue: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        outstandingGr: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        kodeGi: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        tanggalGi: { operator: FilterOperator.AND, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        giQuantity: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        giValue: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        inventory: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        inventorValue: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
        DOI: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    });
    
    const columns = [
        { field: 'kodeProjek', header: 'Kode Projek' },
        { field: 'namaProjek', header: 'Nama Projek' },
        { field: 'statusProjek', header: 'Status Projek' },
        { field: 'namaDivisi', header: 'Nama Divisi' },
        { field: 'namaDepartemen', header: 'Nama Departemen' },
        { field: 'namaMaterialGrup', header: 'Nama Material Group' },
        { field: 'kodeMaterial', header: 'Kode Material' },
        { field: 'namaMaterial', header: 'Nama Material' },
        { field: 'uom', header: 'UOM' },
        { field: 'nomorPo', header: 'Nomor Po' },
        { field: 'tanggalPo', header: 'Tanggal Po' },
        { field: 'poQuantity', header: 'Po Quantity' },
        { field: 'poPrice', header: 'Po Price' },
        { field: 'poTotalValue', header: 'Po Total Value' },
        { field: 'kodeVendor', header: 'Kode Vendor' },
        { field: 'namaVendor', header: 'Nama Vendor' },
        { field: 'kodeGr', header: 'Kode Gr' },
        { field: 'tanggalGr', header: 'Tanggal Gr' },
        { field: 'grQuantity', header: 'Gr Quantity' },
        { field: 'grValue', header: 'Gr value' },
        { field: 'outstandingGr', header: 'Outstanding Gr' },
        { field: 'kodeGi', header: 'Kode Gi' },
        { field: 'tanggalGi', header: 'Tanggal Gi' },
        { field: 'giQuantity', header: 'Gi Quantity' },
        { field: 'giValue', header: 'Gi Value' },
        { field: 'inventory', header: 'Inventory' },
        { field: 'inventorValue', header: 'Inventory Value' },
        { field: 'DOI', header: 'DOI' },
    ];
    
    // const [opsiMultiselectNamaProjek, setOpsiMultiselectNamaProjek] = useState(null)
    // setOpsiMultiselectNamaProjek(namaProjekMap);
    // const initialOpsiMultiselectNamaProjek = null;

    // Inside the component function:
    const [opsiMultiselectNamaProjek, setOpsiMultiselectNamaProjek] = useState();

    // ...

    // In a useEffect with appropriate dependencies:
    // useEffect(() => {
    // // Only update the state when needed
    // setOpsiMultiselectNamaProjek(namaProjekMap);
    // }, []);

    console.log(opsiMultiselectNamaProjek);
    // const columnsNew = [
    //     { field: 'bendungan', header: 'bendungan a' },
    //     { field: 'bandara', header: 'bandara' },
    //     { field: 'akses', header: 'akses a' },
    // ];
    const [defaultColumns] = useState([
        { field: 'namaProjek', header: 'Nama Projek' },
        { field: 'nomorPo', header: 'Nomor Po' },
        { field: 'tanggalPo', header: 'Tanggal Po' },
        { field: 'kodeMaterial', header: 'Kode Material' },
        { field: 'namaMaterial', header: 'Nama Material' },
        { field: 'poQuantity', header: 'Po Quantity' },
        { field: 'uom', header: 'UOM' },
        { field: 'namaVendor', header: 'Nama Vendor' },
        { field: 'inventory', header: 'Inventory' },
        { field: 'inventorValue', header: 'Inventory Value' },
        { field: 'DOI', header: 'DOI' },
    ]);
    const [labelMultiselectNamaProjek] = useState([]);
    // const [defaultColumnsNew] = useState([]);
    const [visibleColumns, setVisibleColumns] = useState([...defaultColumns]);
    const [visibleLabelMultiselectNamaProjek, setVisibleColumnsNew] = useState([...labelMultiselectNamaProjek]);
    // const [visibleColumnsNew, setVisibleColumnsNew] = useState([...defaultColumnsNew]);
    useEffect(() => {
        const fetchData = async () => {
          try {
            const response = await fetch(`http://localhost:4000/api/v1/inventory/data`);
            const jsonData = await response.json();
            const formatDate = (value) => {
              const date = new Date(value);
              const options = {
                weekday: 'short',
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                timeZoneName: 'short',
              };
              return date.toLocaleString('en-US', options);
            };
      
            const dataWithAdditionalFormattedData = jsonData.map((item) => {
              const tanggalGr = new Date(item.tanggalGr);
              const tanggalGi = new Date(item.tanggalGi);
              const selisihTanggal = Math.abs(tanggalGr - tanggalGi) / (1000 * 60 * 60 * 24);
              const DOI = `${selisihTanggal} Hari`;
              return {
                ...item,
                DOI,
                tanggalPo: new Date(formatDate(item.tanggalPo))
              };
            });
      
            setData(dataWithAdditionalFormattedData);
      
            // Menghitung nilai unik dari properti 'namaProjek' setelah data tersedia
            const uniqueValuesNamaProjek = new Set(dataWithAdditionalFormattedData.map(item => item.namaProjek));
            console.log(uniqueValuesNamaProjek);
      
            // Menghasilkan 'namaProjekMap' dari nilai-nilai unik
            const namaProjekMap = Array.from(uniqueValuesNamaProjek).map(namaProjek => ({ namaProjek }));
            console.log(namaProjekMap);

            const field = dataWithAdditionalFormattedData?.length > 0 ? Object.keys(dataWithAdditionalFormattedData[0]) : [];

            setField(field)
      
            // Inisialisasi 'opsiMultiselectNamaProjek' dengan 'namaProjekMap'
            setOpsiMultiselectNamaProjek(namaProjekMap);
      
            // Menghentikan status loading
            setLoading(false);
          } catch (error) {
            console.log("Error fetching data:", error);
          }
        };
      
        fetchData(); // Panggil fetchData saat komponen pertama kali dirender
      }, []);
    // useEffect(() => {
    //     fetchData();
    //     setLoading(false);
    // }, []);
    // useEffect(() => {
    //     setOpsiMultiselectNamaProjek(namaProjekMap);
    // }, [namaProjekMap]);
    // useEffect(()=>{
    //     console.log(filters);
    // }, [filters])
    useEffect(() => {
        // Fungsi ini akan dijalankan ketika data berubah
        // Anda dapat menggunakan ref untuk mengakses nilai dalam Column
        if (data) {
            const newColumnMinWidths = {};
            const newHeaderMinWidths = {};
            visibleColumns.map((col) => {
                // console.log(col.header);
                newColumnMinWidths[col.field] = calculateColumnMinWidth(col.field);
                newHeaderMinWidths[col.header] = calculateHeaderMinWidth(col.header);
            });
            setColumnMinWidths(newColumnMinWidths);
            // setHeaderMinWidths(newHeaderMinWidths);
            // console.log(newColumnMinWidths);
            // console.log(newHeaderMinWidths);
        }
    }, [data, visibleColumns]);
    useEffect(() => {
        // Fungsi ini akan dijalankan ketika data berubah
        // Anda dapat menggunakan ref untuk mengakses nilai dalam Column
        if (data) {
            const newHeaderMinWidths = {};
            columns.map((col) => {
                newHeaderMinWidths[col.header] = calculateHeaderMinWidth(col.header);
            });
            setHeaderMinWidths(newHeaderMinWidths);
            // console.log(newHeaderMinWidths);
        }
    }, [data]);

    // const fetchData = async () => {
    //     try {
    //         const response = await fetch(`http://localhost:4000/api/v1/inventory/data`);
    //         const jsonData = await response.json();
    //         const formatDate = (value) => {
    //             const date = new Date(value);
    //             const options = {
    //                 weekday: 'short',
    //                 year: 'numeric',
    //                 month: 'short',
    //                 day: 'numeric',
    //                 hour: '2-digit',
    //                 minute: '2-digit',
    //                 second: '2-digit',
    //                 timeZoneName: 'short',
    //             };
    //             return date.toLocaleString('en-US', options);
    //         };
    //         // console.log(jsonData);
    //         const dataWithAdditionalFormattedData = jsonData.map((item) => {
    //             const tanggalGr = new Date(item.tanggalGr);
    //             const tanggalGi = new Date(item.tanggalGi);
    //             // const tanggalPo = new Date(item.tanggalPo);
    //             const selisihTanggal = Math.abs(tanggalGr - tanggalGi) / (1000 * 60 * 60 * 24); // Selisih dalam hari
    //             const DOI = `${selisihTanggal} Hari` // Selisih dalam hari
    //             return {
    //                 ...item,
    //                 DOI,
    //                 tanggalPo: new Date(formatDate(item.tanggalPo))
    //                 // tanggalGr,
    //                 // tanggalGi,
    //                 // tanggalPo
    //             };
    //         });

    //         // const dataWithAdditionalFormattedData = jsonData.map((item) => {
    //         //     const { tanggalPo } = item;
    //         //     const tanggalGr = new Date(item.tanggalGr);
    //         //     const tanggalGi = new Date(item.tanggalGi);
    //         //     const selisihTanggal = Math.abs(tanggalGr - tanggalGi) / (1000 * 60 * 60 * 24); // Selisih dalam hari
    //         //     const DOI = `${selisihTanggal} Hari` // Selisih dalam hari

    //         //     return {
    //         //         ...item,
    //         //         tanggalPo: new Date(tanggalPo),
    //         //         tanggalGr: new Date(tanggalGr),
    //         //         tanggalGi: new Date(tanggalGi),
    //         //         DOI, // Tambahkan selisih tanggal ke objek data
    //         //     };
    //         // });


    //         setData(dataWithAdditionalFormattedData);
    //         // setData(jsonData);
    //     } catch (error) {
    //         console.log("Error fetching data:", error);
    //     }
    // };
    const clearFilter = () => {
        initFilters();
    };
    const onGlobalFilterChange = (e) => {
        const value = e.target.value;
        let _filters = { ...filters };

        _filters['global'].value = value;
        // _filters['namaMaterial'].constraints[0].value = value;
        // console.log("New Filters:", _filters);

        setFilters(_filters);
        setGlobalFilterValue(value);
    };

    // const initFilters = () => {
    //     setFilters({
    //         global: { value: null, matchMode: FilterMatchMode.CONTAINS },
    //         kodeProjek: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         namaProjek: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         namaDivisi: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         namaDepartemen: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         namaMaterialGrup: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         kodeMaterial: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         namaMaterial: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         uom: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         nomorPo: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         tanggalPo: { operator: FilterOperator.AND, constraints: [{ value: null, matchMode: FilterMatchMode.DATE_IS }] },
    //         poQuantity: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         poPrice: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         poTotalValue: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         kodeVendor: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         namaVendor: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         kodeGr: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         tanggalGr: { operator: FilterOperator.AND, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         grQuantity: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         grValue: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         outstandingGr: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         kodeGi: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         tanggalGi: { operator: FilterOperator.AND, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         giQuantity: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         giValue: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         inventory: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         inventorValue: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         DOI: { operator: FilterOperator.OR, constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }] },
    //         // namaProjek: {  operator: FilterOperator.OR, constraints: [{value: null, matchMode: FilterMatchMode.CONTAINS}] },
    //         // namaMaterial: { value: null, matchMode: FilterMatchMode.CONTAINS },
    //         // statusProjek: { value: null, matchMode: FilterMatchMode.CONTAINS },
    //         // nomorPo: { value: null, matchMode: FilterMatchMode.CONTAINS },
    //         // kodeGi: { value: null, matchMode: FilterMatchMode.CONTAINS },
    //         // representative: { value: null, matchMode: FilterMatchMode.IN },
    //         // tanggalPo: { operator: FilterOperator.AND, constraints: [{ value: null, matchMode: FilterMatchMode.DATE_IS }] },
    //     });
    //     setGlobalFilterValue('');
    // };
    const initFilters = () => {
        const filters = {};
        field.forEach(field => {
            if (field === "tanggalPo" || field === "tanggalGr" || field === "tanggalGi") {
                filters[field] = {
                    operator: FilterOperator.AND,
                    constraints: [{ value: null, matchMode: FilterMatchMode.DATE_IS }]
                };
            } else {
                filters[field] = {
                    operator: FilterOperator.OR,
                    constraints: [{ value: null, matchMode: FilterMatchMode.CONTAINS }]
                };
            }
        });

        filters.global = { value: null, matchMode: FilterMatchMode.CONTAINS };

        setFilters(filters);
        setGlobalFilterValue('');
    };

    // console.log(data);
    const onColumnToggle = (event) => {
        console.log(event);
        let selectedColumns = event.value;
        let orderedSelectedColumns = columns.filter((col) => selectedColumns.some((sCol) => sCol.field === col.field));
        setVisibleColumns(orderedSelectedColumns);
    };
    
    // Fungsi ini akan menghitung lebar minimum kolom berdasarkan kontennya
    const calculateColumnMinWidth = (field) => {
        let minWidth = 10; // Lebar minimum default
        if (data) {
            data.map((rowData) => {
                const cellContent = rowData[field];
                // console.log(cellContent);
                if (cellContent && cellContent.length * 10 > minWidth) {
                    // Hitung lebar minimum berdasarkan panjang konten
                    minWidth = cellContent.length * 10;
                }
            });
        }
        return minWidth;
    };
    // const calculateHeaderMinWidth = (header) => {
    //     let minWidth = 10; // Lebar minimum default
    //     if (visibleColumns) {
    //         visibleColumns.map((rowData) => {
    //             const cellContent = rowData.header;
    //             console.log(cellContent.length);
    //             if (cellContent && cellContent.length > minWidth) {
    //                 // Hitung lebar minimum berdasarkan panjang konten
    //                 minWidth = cellContent.length * 2;
    //             }
    //         });
    //     }
    //     return minWidth;
    // };
    const calculateHeaderMinWidth = (header) => {
        let minWidth = 10; // Lebar minimum default
        if (columns) {
            columns.map((col) => {
                if (col.header === header) {
                    const cellContent = col.header;
                    if (cellContent && cellContent.length * 10 > minWidth) {
                        // Hitung lebar minimum berdasarkan panjang konten
                        minWidth = cellContent.length * 12;
                    }
                }
            });
        }
        return minWidth;
    };


    const renderHeader = () => {
        return (
            <div className="flex justify-between items-center">
                <div>
                    <SelectButton value={size} onChange={(e) => setSize(e.value)} options={sizeOptions} />
                </div>

                <div>
                    <span className="p-input-icon-left mr-3 ">
                        <i className="pi pi-search" />
                        <InputText value={globalFilterValue} onChange={onGlobalFilterChange} placeholder="Keyword Search" />
                    </span>
                    <Button type="button" icon="pi pi-filter-slash" label="Clear" outlined onClick={clearFilter} />
                </div>
            </div>

        );
    };

    const statusBodyTemplate = (rowData) => {
        return <Text>{rowData.statusProjek}</Text>;
    };
    const statusRowFilterTemplate = (options) => {
        return (
            <Dropdown value={options.value} options={statusesName} onChange={(e) => options.filterApplyCallback(e.value)} placeholder="Select One" className="p-column-filter" showClear style={{ minWidth: '12rem' }} />
        );
    };
    const formatCurrency = (value) => {
        return value.toLocaleString('id-ID', { style: 'currency', currency: 'IDR' });
    };
    const totalProjek = () => {

        const uniqueProjects = new Set();

        data?.map((project) => {
            uniqueProjects.add(project.namaProjek);
            return project; // Kembalikan project untuk memenuhi sintaksis map
        });

        const total = uniqueProjects.size;

        return total;
    };
    const totalInventoryValue = () => {
        let totalValue = 0;

        data?.map((project) => {
            const inventoryValue = parseFloat(project.inventorValue);
            if (!isNaN(inventoryValue)) {
                totalValue += inventoryValue;
            }
            return project;
        });

        return formatCurrency(totalValue);
    };

    const header = renderHeader();
    const renderFooter = () => {
        return (
            <div className="flex justify-between items-center">
                <div>
                    <Text>Total Projek: {totalProjek()} </Text>
                </div>

                <div>
                    <Text>Total Inventory Value: {totalInventoryValue()} </Text>
                </div>
            </div>

        );
    };
    const footer = renderFooter();
    const formatDate = (value) => {
        // console.log(value);

        return value.toLocaleDateString("en-US", {
            day: "2-digit",
            month: "2-digit",
            year: "numeric"
        });
    };

    const dateBodyTemplate = (rowData) => {
        // console.log(formatDate(rowData.tanggalPo));
        // console.log(typeof rowData.tanggalPo);

        return formatDate(rowData.tanggalPo);
    };

    const dateFilterTemplate = (options) => {
        // console.log(options.value);
        return (
            <Calendar
                value={options.value}
                onChange={(e) => options.filterCallback(e.value, options.index)}
                dateFormat="mm/dd/yy"
                placeholder="mm/dd/yyyy"
                mask="99/99/9999"
            />
        );
    };

    const filterApplyTemplate = (options) => {
        return <Button type="button" icon="pi pi-check" onClick={options.filterApplyCallback} severity="success"></Button>;
    };

    const [countries, setCountries] = useState();
    const [selectedCountries, setSelectedCountries] = useState([]);
    const [filteredCountries, setFilteredCountries] = useState(null);

    const search = (event) => {
        // Timeout to emulate a network connection
        setTimeout(() => {
            let _filteredCountries;

            if (!event.query.trim().length) {
                _filteredCountries = [...columns];
            }
            else {
                // _filteredCountries = countries.filter((country) => {
                _filteredCountries = columns.filter((country) => {
                    return country.field.toLowerCase().startsWith(event.query.toLowerCase());
                });
                // console.log(event.query);
            }
            // console.log(_filteredCountries);
            setFilteredCountries(_filteredCountries);
            // console.log(selectedCountries);
        }, 250);
    }

    const onColumnToggleNew = (event) => {
        // console.log('ini event: ', event);
        let selectedColumns = event.value;
        setVisibleColumnsNew(selectedColumns);
        let _filters = { ...filters };
        const constraintValues = selectedColumns.map(item => item.namaProjek);
    
        // Membuat objek baru untuk namaMaterial
        const newNamaMaterialFilter = {
            operator: FilterOperator.OR,
            constraints: constraintValues.length > 0
                ? constraintValues.map(value => ({ value, matchMode: FilterMatchMode.CONTAINS }))
                : [{ value: null, matchMode: FilterMatchMode.CONTAINS }]
        };
    
        _filters['namaProjek'] = newNamaMaterialFilter;
    
    
        setFilters(_filters);
    };
    // const onColumnToggleNew = (event) => {
    //     // console.log('ini event: ', event);
    //     let selectedColumns = event.value;
    //     // let orderedSelectedColumns = columnsNew.filter((col) => selectedColumns.some((sCol) => sCol.field === col.field));
    //     setVisibleColumnsNew(selectedColumns);
    //     // setVisibleColumnsNew(orderedSelectedColumns);
    //     let _filters = { ...filters };
    //     const constraintValues = selectedColumns.map(item => item.field);
    
    //     // Membuat objek baru untuk namaMaterial
    //     const newNamaMaterialFilter = {
    //         operator: FilterOperator.OR,
    //         constraints: constraintValues.length > 0
    //             ? constraintValues.map(value => ({ value, matchMode: FilterMatchMode.CONTAINS }))
    //             : [{ value: null, matchMode: FilterMatchMode.CONTAINS }]
    //     };
    //     // const newNamaMaterialFilter = {
    //     //     operator: FilterOperator.OR,
    //     //     constraints: constraintValues.map(value => ({ value, matchMode: FilterMatchMode.CONTAINS }))
    //     // };
    
    //     _filters['namaProjek'] = newNamaMaterialFilter;
    
    //     // console.log("New Filters:", _filters);
    //     // const updatedSelectedCountries = [...selectedCountries, ...constraintValues];
    
    //     setFilters(_filters);
    //     // setSelectedCountries(updatedSelectedCountries)
    //     // console.log(selectedCountries);
    // };

    const onNamaProjekFilterChange = (e) => {
        console.log('ini e: ', e);
        console.log('ini length e.value : ', e.value.length);
        const arrayOfObjects = e.value; // Anda menerima array objek [{ nama: 'bantu' }, { nama: 'net' }]
        let _filters = { ...filters };
    
        // Membuat array constraints dari nilai array objek
        const lastField = arrayOfObjects[arrayOfObjects.length - 1]?.field;
        console.log('ini field terakhir :', lastField);

        if (lastField) {
            // Membuat objek baru untuk namaMaterial
            const newNamaMaterialFilter = {
                operator: FilterOperator.OR,
                constraints: [{ value: lastField, matchMode: FilterMatchMode.CONTAINS }]
            };

            _filters['namaProjek'] = newNamaMaterialFilter;

            // Menggabungkan nilai baru dengan nilai yang sudah ada dalam selectedCountries
            const updatedSelectedCountries = [...selectedCountries, lastField];

            setFilters(_filters);
            setSelectedCountries(updatedSelectedCountries);
        }
        // const constraintValues = arrayOfObjects.map(item => item.field);
    
        // // Membuat objek baru untuk namaMaterial
        // const newNamaMaterialFilter = {
        //     operator: FilterOperator.OR,
        //     constraints: constraintValues.map(value => ({ value, matchMode: FilterMatchMode.CONTAINS }))
        // };
    
        // _filters['namaProjek'] = newNamaMaterialFilter;
    
        // // console.log("New Filters:", _filters);
        // const updatedSelectedCountries = [...selectedCountries, ...constraintValues];
    
        // setFilters(_filters);
        // setSelectedCountries(updatedSelectedCountries)
        // console.log(selectedCountries);
    };
    useEffect(() => {
        console.log(selectedCountries);
        
    }, [selectedCountries]);

    // useEffect(() => {
    //     setCountries(columns)
    // }, []);





    return (
        <div className="card">
            <Panel header="All Data" className='m-9' toggleable>
                <Panel header="Filter " toggleable>
                    <div className='p-float-label mt-3  '>
                        <MultiSelect filter value={visibleColumns} options={columns} optionLabel="header" onChange={onColumnToggle} className="w-full sm:w-20rem" display="chip" />
                        <label htmlFor="ms-cities">Column</label>
                        {/* <MultiSelect value={selectedCities} onChange={(e) => setSelectedCities(e.value)} options={cities} optionLabel="name" filter placeholder="Select Cities" maxSelectedLabels={3} className="w-full md:w-20rem" /> */}
                    </div>
                    {/* <div className="card p-fluid">
                        <AutoComplete field="field"  multiple value={selectedCountries} suggestions={filteredCountries} completeMethod={search} onChange={onNamaProjekFilterChange} />
                        <AutoComplete field="field"  multiple value={selectedCountries} suggestions={filteredCountries} completeMethod={search} onChange={(e) => setSelectedCountries(e.value)} />
                    </div> */}
                    <div className="flex justify-around items-center w-full pt-8 space-x-5">
                        <div className='p-float-label grow '>
                            <MultiSelect filter value={visibleLabelMultiselectNamaProjek} 
                            options={opsiMultiselectNamaProjek} 
                            // options={columns.map((column, index) => ({
                            //     ...column,
                            //     key: index, // Menggunakan field sebagai kunci yang unik
                            // }))} 
                            optionLabel="namaProjek" onChange={onColumnToggleNew} className="w-full sm:w-20rem" display="chip" />
                            <label htmlFor="ms-cities">Nama Projek</label>
                        </div>
                        {/* <div className='p-float-label grow'>
                            <MultiSelect filter value={visibleColumnsNew} 
                            options={columnsNew} 
                            optionLabel="header" onChange={onColumnToggleNew} className="w-full sm:w-20rem" display="chip" />
                            <label htmlFor="ms-cities">Kode Material</label>
                        </div>
                        <div className='p-float-label grow'>
                            <MultiSelect filter value={visibleColumnsNew} 
                            options={columnsNew} 
                            optionLabel="header" onChange={onColumnToggleNew} className="w-full sm:w-20rem" display="chip" />
                            <label htmlFor="ms-cities">Nomor PO</label>
                        </div> */}
                    </div>
                </Panel>
                {/* <DataTable scrollable removableSort sortMode="multiple" scrollHeight="1000px" value={data} size={size} paginator rows={10} rowsPerPageOptions={[5, 10, 20, 50, 100]} dataKey="id" filters={filters} filterDisplay="row" loading={loading} globalFilterFields={['namaProjek', 'statusProjek', 'nomorPo', 'tanggalPo', 'namaMaterial', 'kodeGi']} header={header} footer={footer} emptyMessage="No data found."> */}
                <DataTable scrollable removableSort dataKey="id" value={data} sortMode="multiple" scrollHeight="1000px" filters={filters} size={size} paginator rows={10} rowsPerPageOptions={[5, 10, 20, 50, 100]} header={header} footer={footer} loading={loading} emptyMessage="No data found."
                    globalFilterFields={field} >
                    {visibleColumns.map((col, index) => (
                        col.field === 'namaProjek' || col.field === 'namaVendor'
                            ?
                            (
                                <Column key={col.field} field={col.field} header={col.header} filterMenuStyle={{ width: 'auto' }} filter style={{ minWidth: `${columnMinWidths[col.field]}px` }} sortable />
                                // <Column key={col.field} field={col.field} header={col.header} filterField="namaMaterial" filterMenuStyle={{ width: 'auto' }} filter style={{ minWidth: `${columnMinWidths[col.field]}px` }} sortable />
                                // <Column key={col.field} field={col.field} header={col.header} showFilterMenu={false} filterMenuStyle={{ width: 'auto' }} filter filterPlaceholder="Search" style={{ minWidth: `${columnMinWidths[col.field]}px` }} sortable />
                            )
                            :
                            col.field === 'tanggalPo' || col.field === 'tanggalGi' || col.field === 'tanggalGr'
                                ?
                                (
                                    <Column key={col.field} field={col.field} header={col.header} filterField="tanggalPo" dataType="date" style={{ minWidth: `${columnMinWidths[col.field]}px` }} body={dateBodyTemplate} filter filterElement={dateFilterTemplate} sortable />
                                    // <Column key={col.field} field={col.field} header={col.header} filterField="tanggalPo" dataType="date" style={{ minWidth: `${columnMinWidths[col.field]}px` }} body={dateBodyTemplate} filter filterElement={dateFilterTemplate} filterPlaceholder="Search" showFilterMenu={true} filterMenuStyle={{ width: 'auto' }}   sortable />
                                    // <Column field='tanggalPo' header="Tanggal PO" filterField="tanggalPo" dataType="date" style={{ minWidth: '10rem' }} body={dateBodyTemplate} filter filterElement={dateFilterTemplate} />
                                )
                                :
                                col.field === 'statusProjek'
                                    ?
                                    (
                                        <Column key={col.field} field={col.field} header={col.header} filterMenuStyle={{ width: '14rem' }} style={{ minWidth: '12rem' }} body={statusBodyTemplate} filter filterElement={statusRowFilterTemplate} showFilterMenu={true} />
                                    )
                                    :
                                    (
                                        <Column key={col.field} field={col.field} header={col.header} showFilterMenu={true} filterMenuStyle={{ width: 'auto' }} filter filterPlaceholder="Search" style={{ minWidth: `${headerMinWidths[col.header]}px` }} sortable />
                                    )

                    ))}
                </DataTable>
            </Panel>
        </div>
    );
}